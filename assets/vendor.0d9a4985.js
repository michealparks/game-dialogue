function O(){}function at(t,e){for(const n in e)t[n]=e[n];return t}function I(t){return t()}function D(){return Object.create(null)}function b(t){t.forEach(I)}function P(t){return typeof t=="function"}function ut(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}let v;function ft(t,e){return v||(v=document.createElement("a")),v.href=e,t===v.href}function U(t){return Object.keys(t).length===0}function lt(t){return t==null?"":t}function dt(t){return t&&P(t.destroy)?t.destroy:O}function ht(t,e){t.appendChild(e)}function V(t,e,n){t.insertBefore(e,n||null)}function J(t){t.parentNode.removeChild(t)}function W(t){return document.createElement(t)}function K(t){return document.createTextNode(t)}function _t(){return K(" ")}function mt(){return K("")}function gt(t,e,n,s){return t.addEventListener(e,n,s),()=>t.removeEventListener(e,n,s)}function X(t,e,n){n==null?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function yt(t,e,n){e in t?t[e]=typeof t[e]=="boolean"&&n===""?!0:n:X(t,e,n)}function Y(t){return Array.from(t.childNodes)}function pt(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}function $t(t,e){t.value=e==null?"":e}function wt(t,e,n){t.classList[n?"add":"remove"](e)}function Z(t,e,n=!1){const s=document.createEvent("CustomEvent");return s.initCustomEvent(t,n,!1,e),s}class kt{constructor(){this.e=this.n=null}c(e){this.h(e)}m(e,n,s=null){this.e||(this.e=W(n.nodeName),this.t=n,this.c(e)),this.i(s)}h(e){this.e.innerHTML=e,this.n=Array.from(this.e.childNodes)}i(e){for(let n=0;n<this.n.length;n+=1)V(this.t,this.n[n],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(J)}}let k;function w(t){k=t}function tt(){if(!k)throw new Error("Function called outside component initialization");return k}function bt(){const t=tt();return(e,n)=>{const s=t.$$.callbacks[e];if(s){const a=Z(e,n);s.slice().forEach(u=>{u.call(t,a)})}}}const $=[],F=[],A=[],G=[],et=Promise.resolve();let q=!1;function nt(){q||(q=!0,et.then(Q))}function H(t){A.push(t)}const T=new Set;let j=0;function Q(){const t=k;do{for(;j<$.length;){const e=$[j];j++,w(e),st(e.$$)}for(w(null),$.length=0,j=0;F.length;)F.pop()();for(let e=0;e<A.length;e+=1){const n=A[e];T.has(n)||(T.add(n),n())}A.length=0}while($.length);for(;G.length;)G.pop()();q=!1,T.clear(),w(t)}function st(t){if(t.fragment!==null){t.update(),b(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(H)}}const C=new Set;let y;function xt(){y={r:0,c:[],p:y}}function Et(){y.r||b(y.c),y=y.p}function R(t,e){t&&t.i&&(C.delete(t),t.i(e))}function it(t,e,n,s){if(t&&t.o){if(C.has(t))return;C.add(t),y.c.push(()=>{C.delete(t),s&&(n&&t.d(1),s())}),t.o(e)}}function vt(t,e){it(t,1,1,()=>{e.delete(t.key)})}function jt(t,e,n,s,a,u,r,l,i,o,p,h){let f=t.length,_=u.length,d=f;const S={};for(;d--;)S[t[d].key]=d;const x=[],M=new Map,N=new Map;for(d=_;d--;){const c=h(a,u,d),m=n(c);let g=r.get(m);g?s&&g.p(c,e):(g=o(m,c),g.c()),M.set(m,x[d]=g),m in S&&N.set(m,Math.abs(d-S[m]))}const z=new Set,B=new Set;function L(c){R(c,1),c.m(l,p),r.set(c.key,c),p=c.first,_--}for(;f&&_;){const c=x[_-1],m=t[f-1],g=c.key,E=m.key;c===m?(p=c.first,f--,_--):M.has(E)?!r.has(g)||z.has(g)?L(c):B.has(E)?f--:N.get(g)>N.get(E)?(B.add(g),L(c)):(z.add(E),f--):(i(m,r),f--)}for(;f--;){const c=t[f];M.has(c.key)||i(c,r)}for(;_;)L(x[_-1]);return x}function At(t,e){const n={},s={},a={$$scope:1};let u=t.length;for(;u--;){const r=t[u],l=e[u];if(l){for(const i in r)i in l||(s[i]=1);for(const i in l)a[i]||(n[i]=l[i],a[i]=1);t[u]=l}else for(const i in r)a[i]=1}for(const r in s)r in n||(n[r]=void 0);return n}function Ct(t){return typeof t=="object"&&t!==null?t:{}}function St(t){t&&t.c()}function ot(t,e,n,s){const{fragment:a,on_mount:u,on_destroy:r,after_update:l}=t.$$;a&&a.m(e,n),s||H(()=>{const i=u.map(I).filter(P);r?r.push(...i):b(i),t.$$.on_mount=[]}),l.forEach(H)}function ct(t,e){const n=t.$$;n.fragment!==null&&(b(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function rt(t,e){t.$$.dirty[0]===-1&&($.push(t),nt(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function Mt(t,e,n,s,a,u,r,l=[-1]){const i=k;w(t);const o=t.$$={fragment:null,ctx:null,props:u,update:O,not_equal:a,bound:D(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(i?i.$$.context:[])),callbacks:D(),dirty:l,skip_bound:!1,root:e.target||i.$$.root};r&&r(o.root);let p=!1;if(o.ctx=n?n(t,e.props||{},(h,f,..._)=>{const d=_.length?_[0]:f;return o.ctx&&a(o.ctx[h],o.ctx[h]=d)&&(!o.skip_bound&&o.bound[h]&&o.bound[h](d),p&&rt(t,h)),f}):[],o.update(),p=!0,b(o.before_update),o.fragment=s?s(o.ctx):!1,e.target){if(e.hydrate){const h=Y(e.target);o.fragment&&o.fragment.l(h),h.forEach(J)}else o.fragment&&o.fragment.c();e.intro&&R(t.$$.fragment),ot(t,e.target,e.anchor,e.customElement),Q()}w(i)}class Nt{$destroy(){ct(this,1),this.$destroy=O}$on(e,n){const s=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return s.push(n),()=>{const a=s.indexOf(n);a!==-1&&s.splice(a,1)}}$set(e){this.$$set&&!U(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}export{R as A,it as B,ct as C,xt as D,jt as E,Et as F,at as G,kt as H,vt as I,Nt as S,_t as a,X as b,yt as c,V as d,W as e,ht as f,$t as g,J as h,Mt as i,bt as j,F as k,gt as l,ft as m,O as n,wt as o,pt as p,lt as q,b as r,ut as s,K as t,dt as u,mt as v,St as w,ot as x,At as y,Ct as z};
